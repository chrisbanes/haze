{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Haze is a library providing a 'glassmorphism' style blur for Compose.</p> <p></p> <p>Haze is built with Compose Multiplatform, meaning that it supports different platforms:</p> Platform Supported Android \u2705 Desktop (JVM) \u2705 iOS \u2705 Wasm \u2705 JS/Canvas \u2705 <p>You can also see it in action in the Tivi app:</p> <p></p>"},{"location":"#download","title":"Download","text":"<pre><code>repositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"dev.chrisbanes.haze:haze:&lt;version&gt;\")\n}\n</code></pre>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>In previous versions, the Skia-backed implementation (used on iOS and Desktop) was heavily influenced by Kirill Grouchnikov's explorations on Compose Desktop. He wrote about it in his Shader based render effects in Compose Desktop with Skia blog post.</p> <p>The Android implementation was inspired by the techniques documented by Chet Haase and Nader Jawad in the RenderNode for Bigger, Better Blurs blog post.</p> <p>Thank you all.</p>"},{"location":"#license","title":"License","text":"<pre><code>Copyright 2024 Chris Banes\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    https://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"faq/","title":"FAQs","text":""},{"location":"faq/#whats-the-difference-between-this-and-modifierblur","title":"What's the difference between this and Modifier.blur?","text":"<p>The Modifier.blur modifier and Haze may sound similar, but what they provide is different.</p> <p>Haze provides background blurring, meaning that it will blur content behind, not the content itself. This is what you need to implement glass-like effects. Other than that, Haze provides a whole bunch of other features which you can read about on the Usage page.</p>"},{"location":"faq/#are-the-blur-implementations-the-same-across-different-platforms","title":"Are the blur implementations the same across different platforms?","text":"<p>In v1.0 onwards, all platforms use the same implementation (mostly).</p> <p>In older versions of Haze (older than v1.0), the Android implementation was always built upon RenderNode and RenderEffect. In Compose 1.7.0, we now have access to new GraphicsLayer APIs, which are similar to RenderNode, but available in <code>commonMain</code> in Compose Multiplatform.</p> <p>The migration to GraphicsLayer has resulted in Haze now having a single implementation across all platforms. This helps minimize platform differences and bugs. There are differences in the platform RenderEffects which we use for actual effect though. These are platform specific, and need to use platform APIs, but the way they are written is very similar.</p>"},{"location":"faq/#what-versions-of-android-does-haze-work-on","title":"What versions of Android does Haze work on?","text":"<p>Haze works on all versions of Android, but the effect it uses differs based on the version of Android that it is running on.</p> <ul> <li>When running on Android 12 and above (API Level 31): Haze utilizes RenderEffects for blurring, and is enabled by default.</li> <li>When running on older versions of Android: Haze v1.6.0 and newer can now use RenderScript to achieve similar blurring as newer platforms. This is not enabled by default. See the docs here on how to enable it.</li> <li>When blurring is disabled, Haze will use a scrim (translucent overlay).</li> </ul>"},{"location":"faq/#renderscript","title":"RenderScript","text":"<p>The RenderScript implementation, used on devices running Android 11 or older, is new in Haze v1.6.0 and considered experimental. \u26a0\ufe0f</p> <p>It attempts to bring a consistent blurring experience as provided by newer platforms, but prioritizes performance over staying in sync with content behind. Using RenderScript means that processing a draw frame can take longer than our allocated frame time. To combat this, Haze uses a background thread to process frames. This means that content updates will nearly always be a frame (or more) behind. </p> <p>In addition to this, Haze will skip any new content if it is still processing a previous frame. This is to ensure that Haze does not unintentionally create a queue of frames, and potentially overwhelm the device.</p> <p>To the user the blur effect may look 'laggy' or slow to update. This is the compromise Haze makes.</p>"},{"location":"materials/","title":"Materials","text":"<p>We provide off of the shelf implementations of HazeStyles which implement 'materials' of various styles.</p>"},{"location":"materials/#download","title":"Download","text":"<pre><code>repositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"dev.chrisbanes.haze:haze-materials:&lt;version&gt;\")\n}\n</code></pre>"},{"location":"materials/#hazematerials","title":"HazeMaterials","text":"<p>A class which contains functions to build HazeStyles which implement 'material-like' styles. It is inspired by the material APIs available in SwiftUI, but it makes no attempt to provide the exact effects provided in iOS (unlike CuperintoMaterials below).</p> <p></p> <p>Class reference: HazeMaterials.</p>"},{"location":"materials/#cupertinomaterials","title":"CupertinoMaterials","text":"<p>A class which contains functions to build HazeStyles which implement 'material' styles similar to those available on Apple platforms. The values used are taken from the iOS 18 Figma file published by Apple.</p> <p>The primary use case for using these is for when aiming for consistency with native UI (i.e. for when mixing Compose Multiplatform content alongside SwiftUI content).</p> <p></p> <p>Class reference: CupertinoMaterials.</p>"},{"location":"materials/#fluentmaterials","title":"FluentMaterials","text":"<p>These implement 'material' styles similar to those available on Windows platforms. The values used are taken from the WinUI 3 Figma file published by Microsoft.</p> <p>The primary use case for using these is for when aiming for consistency with native UI (i.e. for when mixing Compose Multiplatform content alongside WinUI content).</p> <p></p> <p>Class reference: FluentMaterials.</p>"},{"location":"materials/#usage","title":"Usage","text":"<p>All of these are provided through functions on the relevant materials class, with each function providing a different level of material.</p> <pre><code>Box {\n  // rest of sample from above\n\n  LargeTopAppBar(\n    modifier = Modifier\n      .hazeEffect(\n        ...\n        style = HazeMaterials.thin(),\n      ),\n  )\n}\n</code></pre>"},{"location":"migrating-1.0/","title":"Migrating to 1.0","text":""},{"location":"migrating-1.0/#changes","title":"Changes","text":"<p>Here's a list of known changes in v1.0.x. There may be others, so please file issues if you encounter other unexpected changes.</p>"},{"location":"migrating-1.0/#functional-changes","title":"Functional changes","text":""},{"location":"migrating-1.0/#haze-no-longer-clips-background-content","title":"Haze no longer clips background content","text":"<p>This means that blurred areas may appear less blurry at first, as you're seeing the original content behind, and then the blurred content on top. This clipping has been removed, as the clipped areas can't take part in translations, scales, etc.</p> <p>Change: Use the <code>backgroundColor</code> property on <code>HazeStyle</code> to set an appropriate opaque background color. The <code>HazeMaterial</code>s automatically use the Material3 Surface color, so you may have nothing to do here.</p>"},{"location":"migrating-1.0/#blurred-effect-may-look-different","title":"Blurred effect may look different","text":"<p>As we're now using a common implementation on all platforms, the Skia-backed platforms now have a completely different implementation. Haze has also tried to maintain consistency across the platforms, so the differences should be small. However the differences will likely trigger screenshot tests to fail.</p> <p>Change: This is working as intended for small changes, so go ahead and update your screenshot golden images. If you feel that the differences are too large, please file an issue with examples.</p>"},{"location":"migrating-1.0/#api-changes","title":"API changes","text":""},{"location":"migrating-1.0/#more-styling-parameters","title":"More styling parameters","text":"<ul> <li>What: We now have more styling parameters, including a mask <code>Brush</code>, and alpha parameter.</li> <li>Why: More is more, right?</li> </ul>"},{"location":"migrating-1.0/#hazechildscope","title":"\ud83c\udd95 HazeChildScope","text":"<ul> <li>What: We now have a parameter on <code>Modifier.hazeChild</code> which allow you to provide a lambda block for controlling all of Haze's styling parameters. It is similar to concept to <code>Modifier.graphicsLayer { ... }</code>. See here for more information.</li> <li>Why: This has been primarily added to aid animating Haze's styling parameters, in a performant way.</li> </ul>"},{"location":"migrating-1.0/#default-style-functionality-on-modifierhaze-has-been-moved","title":"Default style functionality on Modifier.haze has been moved","text":"<ul> <li>What: In previous versions, there was a <code>style</code> parameter on <code>Modifier.haze</code>, which has been moved in v1.0.</li> <li>Migration: Use the new LocalHazeStyle composition local instead.</li> <li>Why: Composition locals are used throughout styling frameworks, so this is a better API going forward.</li> </ul>"},{"location":"migrating-1.0/#hazearea-has-been-removed","title":"HazeArea has been removed","text":"<ul> <li>What: The <code>HazeArea</code> class has been removed</li> <li>Migration: None. This was mostly an internal API so if you did have a use case for this, let me know via an issue.</li> <li>Why: HazeArea instances were how we updated <code>Modifier.haze</code> instances about individual children (back-writes). With the changes listed below, drawing is now the responsibility of the children themselves, therefore there is no need to communicate this state back up.</li> </ul>"},{"location":"migrating-1.0/#why-have-these-changes-been-made","title":"Why have these changes been made?","text":"<p>Below we'll go through some of the background of the changes in v1.0. You don't need to know this stuff, but it might be interesting for some.</p>"},{"location":"migrating-1.0/#graphicslayers","title":"GraphicsLayers","text":"<p>For Haze, the most exciting APIs we now have access are the new GraphicsLayer APIs. These are very similar to RenderNodes in Android, which Haze has always used on Android. In a very short summary, GraphicsLayers give us a common API to use on all platforms.</p> <p>This has resulted in Haze now having a single implementation across all platforms now, re-using the old Android implementation. This should help minimize platform differences, and bugs.</p>"},{"location":"migrating-1.0/#new-pipeline","title":"New pipeline","text":"<p>In v0.7 and older, Haze is all 'smoke and mirrors'. It draws all of the blurred areas in the <code>haze</code> layout node. The <code>hazeChild</code> nodes just update the size, shape, etc, which the <code>haze</code> modifier reads, to know where to draw.</p> <p>With the adoption of GraphicsLayers, we now have a way to pass 'drawn' content around, meaning that we are no longer bound by the restraints of before. v1.0 contains a re-written drawing pipeline, where the blurred content is drawn by the <code>hazeChild</code>, not the parent. The parent <code>haze</code> is now only responsible for drawing the background content into a graphics layer, and putting it somewhere for the children to access.</p> <p>This fixes a number of long-known issues on Haze, where all were caused by the fact that the blurred area wasn't drawn by the child.</p>"},{"location":"performance/","title":"Performance","text":"<p>Real-time blurring is a non-trivial operation, especially for mobile devices, so developers are rightly worried about the performance impact of using something like Haze.</p> <p>Haze tries to use the most performant mechanism possible on each platform, which can basically be simplified into 2: <code>RenderEffect</code> on Android, and using Skia's <code>ImageFilter</code>s directly on iOS and Desktop.</p>"},{"location":"performance/#input-scale","title":"Input Scale","text":"<p>You can provide an input scale value which determines how much the content is scaled in both the x and y dimensions, allowing the blur effect to be potentially applied over scaled-down content (and thus less pixels), before being scaled back up and drawn at the original size. You can find more information on how to use this here.</p> <p>In terms of the performance benefit which scaling provides, it's fairly small. In our Android benchmark tests, using an <code>inputScale</code> set to <code>0.5</code> reduced the cost of Haze by 5-20%. You can read more about this below.</p> <p>Cost of Haze</p> <p>Just to call out: the percentage that I mentioned is a reduction in the cost of Haze, not the total frame duration. Haze itself introduces a cost, which you can read more about below. The reduction in total frame duration duration will be in the region of 3-5%.</p>"},{"location":"performance/#benchmarks","title":"Benchmarks","text":"<p>To quantify performance, we have a number of Macrobenchmark tests to measure Haze's effect on drawing performance on Android. We'll be using these on every major release to ensure that we do not unwittingly regress performance.</p> <p>Anyway, in the words of Jerry Maguire, \"Show Me The Money\"...</p> <p>We currently have 4 benchmark scenarios, each of them is one of the samples in the sample app, and picked to cover different things:</p> <ul> <li>Scaffold. The simple example, where the app bar and bottom navigation bar are blurred, with a scrollable list. This example uses rectangular haze areas.</li> <li>Scaffold, with progressive. Same as Scaffold, but using a progressive blur.</li> <li>Images List. Each item in the list has it's own <code>hazeSource</code> and <code>hazeEffect</code>. As each item has it's own <code>hazeSource</code>, the internal haze state does not change all that much (the list item content moves, but the <code>hazeEffect</code> doesn't in terms of local coordinates). This is more about multiple testing <code>RenderNode</code>s. This example uses rounded rectangle haze areas (i.e. we use <code>clipPath</code>).</li> <li>Credit Card. A simple example, where the user can drag the <code>hazeEffect</code>. This tests how fast Haze's internal state invalidates and propogates to the <code>RenderNode</code>s. This example uses rounded rectangle haze areas like 'Images List'.</li> </ul> <p>Test setup</p> <p>All of the tests were ran with 16 iterations on a Pixel 6, running the latest version of Android available.</p> <p>As with all benchmark tests, the results are only true for the exact things being tested. Using Haze in your own applications may result in different performance characteristics, so it is wise to write your own performance tests to validate the impact to your apps. Benchmark tests will always have variability in them too, so don't take the numbers listed below as exact values. Look at them more as a guide.</p> <p>The numbers listed below the P90 frame durations in milliseconds, which tend to be a good indicator of frames where a user interaction is happening (scrolling, etc). However, as these are the P90 values, these indicate the longest 10% frame durations, and thus are (probably) not indicitive of the performance which users see most of the time. It all depends on the distribution of the frame durations, but we're quickly getting into entry-level statistics, which is beyond what we're trying to document here.</p>"},{"location":"performance/#cost-of-haze","title":"Cost of Haze","text":"<p>We can also measure the rough cost of using Haze in the same samples. Here we've ran the same tests, with Haze being completely disabled:</p> Test 1.0.x (disabled) 1.0.x Difference Scaffold 7.5 ms 9.7 ms +29% Images List 6.6 ms 9.6 ms +45% Credit Card 6.6 ms 13.1 ms +98%"},{"location":"performance/#cost-of-features","title":"Cost of features","text":"<p>We can also measure the rough cost of using features, such as input scale, progressive and masking:</p> Test P90 frame duration (ms) Difference (in Haze cost) Scaffold 9.7 ms - Scaffold (inputScale = 0.5) 9.6 ms -5% Scaffold (masked) 9.8 ms +5% Scaffold (progressive) 9.7 ms 0% Scaffold (progressive, inputScale = 0.5) 9.4 ms -14% <p>The values are all very close, with the differences easily being within a margin of error, so don't use these differences as exact values (especially with the variability that we mentioned above). I think there's two big take aways here though:</p> <ul> <li>Masking has a negligible effect on frame durations.</li> <li>Progessive has a negligible effect on frame durations, when using using our custom blur shader (Android SDK 34+, all other platforms).</li> <li>Input Scale has a small but positive effect on frame duration.</li> </ul> <p>Full results</p> <p>For those interested, you can find the full results in this spreadsheet.</p>"},{"location":"recipes/","title":"Recipes","text":""},{"location":"recipes/#scaffold","title":"Scaffold","text":"<p>Blurring the content behind app bars is a common use case, so how can we use Haze with <code>Scaffold</code>? It's pretty much the same as above:</p> <p>Multiple hazeEffects</p> <p>Note: We are using multiple <code>hazeEffect</code>s in this example. You can actually use an abitrary number of <code>hazeEffect</code>s.</p> <pre><code>val hazeState = rememberHazeState()\n\nScaffold(\n  topBar = {\n    TopAppBar(\n      // Need to make app bar transparent to see the content behind\n      colors = TopAppBarDefaults.largeTopAppBarColors(Color.Transparent),\n      modifier = Modifier\n        .hazeEffect(state = hazeState)\n        .fillMaxWidth(),\n    ) {\n      /* todo */\n    }\n  },\n  bottomBar = {\n    NavigationBar(\n      containerColor = Color.Transparent,\n      modifier = Modifier\n        .hazeEffect(state = hazeState)\n        .fillMaxWidth(),\n    ) {\n      /* todo */\n    }\n  },\n) {\n  LazyVerticalGrid(\n    modifier = Modifier\n      .hazeSource(\n        state = hazeState,\n        style = HazeDefaults.style(backgroundColor = MaterialTheme.colorScheme.surface),\n      ),\n  ) {\n    // todo\n  }\n}\n</code></pre>"},{"location":"recipes/#sticky-headers","title":"Sticky Headers","text":"<p>The <code>stickyHeader</code> functionality on <code>LazyColumn</code> and friends is very useful, but unfortunately the limitations of Haze means that blurring the list contents for the header background is tricky.</p> <p>Since we can not use <code>Modifier.hazeSource</code> on the <code>LazyColumn</code> and <code>Modifier.hazeEffect</code> on items, as we would get into recursive drawing, we need to get a bit more creative.</p> <p>Since we can have multiple nodes using <code>Modifier.hazeSource</code>, we can use the modifier on all non-header items, and then use <code>hazeEffect</code> as normal on the <code>stickyHeader</code>:</p> <pre><code>val hazeState = rememberHazeState()\n\nLazyColumn(...) {\n  stickyHeader {\n    Header(\n      modifier = Modifier\n        .hazeEffect(state = hazeState),\n    )\n  }\n\n  items(list) { item -&gt;\n    Foo(\n      modifier = Modifier\n        .hazeSource(hazeState),\n    )\n  }\n}\n</code></pre> <p>A more complete example can be found here: ListWithStickyHeaders.</p> <p></p>"},{"location":"usage/","title":"Usage","text":"<p>Haze is implemented through two Compose Modifiers: Modifier.hazeSource and Modifier.hazeEffect.</p> <p>The most basic usage would be something like:</p> <pre><code>val hazeState = rememberHazeState()\n\nBox {\n  LazyColumn(\n    modifier = Modifier\n      .fillMaxSize()\n      // Pass it the HazeState we stored above\n      .hazeSource(state = hazeState)\n  ) {\n    // todo\n  }\n\n  LargeTopAppBar(\n    // Need to make app bar transparent to see the content behind\n    colors = TopAppBarDefaults.largeTopAppBarColors(Color.Transparent),\n    modifier = Modifier\n      // We use hazeEffect on anything where we want the background\n      // blurred.\n      .hazeEffect(state = hazeState, style = HazeMaterials.ultraThin())\n      .fillMaxWidth(),\n  )\n}\n</code></pre> <p>You will notice that were using a style created by <code>HazeMaterials.ultraThin()</code>. The HazeMaterials are sets of prebuilt styles that are available as an add-on library.</p> <p>If you do not provide an explicit style, the default values will provide basic blurring, but no tinting. It's recommended to use one of the materials linked above, or a custom style which meets your requirements.</p>"},{"location":"usage/#styling","title":"Styling","text":"<p>Haze has support for customizing the resulting effect, which is performed via the HazeStyle class, or the lambda block provided to <code>hazeEffect</code>.</p> <p>Styles can be provided in a number of different ways:</p> <ul> <li>LocalHazeStyle composition local.</li> <li>The style parameter on Modifier.hazeEffect.</li> <li>By setting the relevant property in the optional HazeEffectScope lambda <code>block</code>, passed into Modifier.hazeEffect.</li> </ul>"},{"location":"usage/#hazeeffectscope","title":"HazeEffectScope","text":"<p>We now have a parameter on <code>Modifier.hazeEffect</code> which allow you to provide a lambda block, for controlling all of Haze's styling parameters. It is similar to concept to <code>Modifier.graphicsLayer { ... }</code>.</p> <p>It's useful for when you need to update styling parameters, using values derived from other state. Here's an example which fades the effect as the user scrolls:</p> <pre><code>FooAppBar(\n  ...\n  modifier = Modifier\n    .hazeEffect(state = hazeState) {\n      alpha = if (listState.firstVisibleItemIndex == 0) {\n        listState.layoutInfo.visibleItemsInfo.first().let {\n          (it.offset / it.size.height.toFloat()).absoluteValue\n        }\n      } else {\n        alpha = 1f\n      }\n    },\n)\n</code></pre>"},{"location":"usage/#styling-resolution","title":"Styling resolution","text":"<p>As we a few different ways to set styling properties, it's important to know how the final values are resolved.</p> <p>Each styling property (such as <code>blurRadius</code>) is resolved seperately, and the order of precedence for each property is as follows, in order:</p> <ul> <li>Value set in HazeEffectScope, if specified.</li> <li>Value set in style provided to hazeEffect (or HazeEffectScope.style), if specified.</li> <li>Value set in the LocalHazeStyle composition local.</li> </ul>"},{"location":"usage/#styling-properties","title":"Styling properties","text":""},{"location":"usage/#blur-radius","title":"Blur Radius","text":"<p>The blur radius controls how strong the blur effect is. This defaults to <code>20.dp</code> but can be customized as needed. Larger values might be needed to keep foreground control (such as text) legible and accessible.</p>"},{"location":"usage/#tint","title":"Tint","text":"<p>A tint effect is applied, primarily to maintain contrast and legibility. By default we use the provided background color at 70% opacity. You may wish to use a different color or opacity. You provide multiple tints, which will be applied in sequence.</p>"},{"location":"usage/#noise","title":"Noise","text":"<p>Some visual noise is applied, to provide some tactility. This is completely optional, and defaults to a value of <code>0.15f</code> (15% strength). You can disable this by providing <code>0f</code>.</p>"},{"location":"usage/#progressive-aka-gradient-blurs","title":"Progressive (aka gradient) blurs","text":"<p>Progressive blurs allow you to provide a visual effect where the blur radius is varied over a dimension. You may have seen this effect used on iOS.</p> <p></p> <p>Progressive blurs can be enabled by setting the <code>progressive</code> property on HazeEffectScope. The API is very similar to the Brush gradient APIs, so it should feel familiar.</p> <pre><code>LargeTopAppBar(\n  // ...\n  modifier = Modifier.hazeEffect(hazeState) {\n    progressive = HazeProgressive.verticalGradient(startIntensity = 1f, endIntensity = 0f)\n  }\n)\n</code></pre> <p>There are a number of different types of progressive effect supported in Haze:</p>"},{"location":"usage/#linear-gradient","title":"Linear Gradient","text":"<p>Class documentation: HazeProgressive.LinearGradient</p> <p>Linear gradients, usually vertical or horizontal, but you can set any angle.</p> <p>There are a few builder functions on <code>HazeProgressive</code>, enabling common use cases: verticalGradient and horizontalGradient.</p> <pre><code>LargeTopAppBar(\n  // ...\n  modifier = Modifier.hazeEffect(hazeState) {\n    progressive = HazeProgressive.verticalGradient(startIntensity = 1f, endIntensity = 0f)\n  }\n)\n</code></pre>"},{"location":"usage/#radial-gradient","title":"Radial Gradient","text":"<p>Class documentation: HazeProgressive.RadialGradient</p> <p>A radial gradient, with a defined center and radius.</p> <pre><code>LargeTopAppBar(\n  // ...\n  modifier = Modifier.hazeEffect(hazeState) {\n    progressive = HazeProgressive.RadialGradient()\n  }\n)\n</code></pre>"},{"location":"usage/#custom-brush","title":"Custom Brush","text":"<p>Class documentation: HazeProgressive.Brush</p> <p>A custom progressive effect, using a given Brush as the alpha mask for the entire effect.</p> <p>Commonly this will be used to create along with a custom Shader, so we have a builder function to make this easier: forShader</p> <pre><code>LargeTopAppBar(\n  // ...\n  modifier = Modifier.hazeEffect(hazeState) {\n    progressive = HazeProgressive.forShader { size -&gt;\n      // TODO: return platform-specific Shader using the given size\n    }\n  }\n)\n</code></pre> <p>The Shader class is not commonized in Compose Multiplatform (it's an alias to the platform specific class), therefore you will likely need to use <code>expect</code> and <code>actual</code> functions to build the relevant shader.</p> <p>Performance of Progressive</p> <p>Please be aware that using progressive blurring does come with a performance cost. Please see the Performance page for up-to-date benchmarks.</p> <p>As a quick summary: on Android SDK 33+ and other platforms, the cost is about 25% more than non-progressive. On Android SDK 32 it is about 2x. If performance is critical, you may wish to look at the masking functionality below.</p>"},{"location":"usage/#masking","title":"Masking","text":"<p>You can provide any Brush, which will be used as a mask when the final effect is drawn.</p> <pre><code>LargeTopAppBar(\n  // ...\n  modifier = Modifier.hazeEffect(hazeState) {\n    mask = Brush.verticalGradient(...)\n  }\n)\n</code></pre> <p>Mask vs Progressive</p> <p>When you provide a gradient brush as a mask, the effect is visually similar to a gradient blur. The difference is that the effect is faded through opacity only, and may not feel as refined. However, it is much faster than progressive blurring, having a negligible cost.</p>"},{"location":"usage/#input-scale","title":"Input Scale","text":"<p>You can provide an input scale value which determines how much the content is scaled in both the x and y dimensions, allowing the blur effect to be potentially applied over scaled-down content (and thus less pixels), before being scaled back up and drawn at the original size.</p> <p></p> <pre><code>LargeTopAppBar(\n  // ...\n  modifier = Modifier.hazeEffect(hazeState) {\n    inputScale = HazeInputScale.Auto\n  }\n)\n</code></pre> <p>HazeInputScale has a number of different options:</p> <ul> <li><code>HazeInputScale.None</code>: Turns off input scaling (default)</li> <li><code>HazeInputScale.Auto</code>: Turns on input scaling, with automatic values derived underneath.</li> <li><code>HazeInputScale.Fixed(...)</code>: Turns on input scaling, using the value you pass in.</li> </ul> <p>When using a <code>Fixed</code> value, less than 1.0 may improve performance, at the sacrifice of quality and crispness. As always, run your own benchmarks as to whether this compromise is worth it.</p> <p>If you're looking for a good value to experiment with, <code>0.66</code> results in a reduction in total resolution of ~55%, while being visually imperceptible to most people (probably).</p> <p>The minimum value I would realistically use is somewhere in the region of <code>0.33</code>, which results in the total pixel count of only 11% of the original content. This is likely to be visually different to no scaling, but depending on the styling parameters, it will be visually pleasing to the user.</p>"},{"location":"usage/#overlapping-blurred-layouts","title":"Overlapping blurred layouts","text":"<p>A layout node can use both a <code>Modifier.hazeEffect</code>, drawing a blurred effect from other areas, and use <code>Modifier.hazeSource</code> to draw itself for other <code>hazeEffect</code> users.</p> <p>This nested functionality sounds complicated, but in reality it enables a simple use case: overlapping blurred layout nodes.</p> <p></p> <p>This code to implement this is like below. You can see that the <code>CreditCard()</code> nodes use both the <code>hazeSource</code> and <code>hazeEffect</code> modifiers. Pay attention to the modifier order here.</p> <pre><code>Box {\n  val hazeState = rememberHazeState()\n\n  Background(\n    modifier = Modifier\n      .hazeSource(hazeState, zIndex = 0f)\n  )\n\n  // Rear card\n  CreditCard(\n    modifier = Modifier\n      .hazeSource(hazeState, zIndex = 1f)\n      .hazeEffect(hazeState)\n  )\n\n  // Middle card\n  CreditCard(\n    modifier = Modifier\n      .hazeSource(hazeState, zIndex = 2f)\n      .hazeEffect(hazeState),\n  )\n\n  // Front card\n  CreditCard(\n    modifier = Modifier\n      .hazeSource(hazeState, zIndex = 3f)\n      .hazeEffect(hazeState)\n  )\n}\n</code></pre> <p>You will notice that there's something different here, the <code>zIndex</code> parameter.</p> <p>For this to work you need to pass in the <code>zIndex</code> parameter of the node. It doesn't matter if you use <code>Modifier.zIndex</code>, or the implicit ordering from the layout, you need to explicitly pass in a valid <code>zIndex</code> value.</p>"},{"location":"usage/#zindex","title":"zIndex","text":"<p>Internally, the zIndex value is how Haze knows which layers to draw in which nodes. By default, <code>hazeEffect</code> will draw all layers with a <code>zIndex</code> less than the value of the sibling <code>Modifier.hazeSource</code>. So in the example above, the middle card (<code>zIndex</code> of 2) will draw the rear card (<code>zIndex</code> of 1) and background (<code>zIndex</code> of 0).</p> <p>This default behavior is usually the correct behavior for all use cases, but you can modify this behavior via the <code>canDrawArea</code> parameter, which acts as a filter when set:</p> <pre><code>CreditCard(\n  modifier = Modifier\n    .hazeSource(hazeState, zIndex = 2f, key = \"foo\")\n    .hazeEffect(hazeState) {\n      canDrawArea = { area -&gt;\n        // return true to draw\n        area.key != \"foo\"\n      }\n    },\n)\n</code></pre> <p>You'll notice that we're using another parameter here, <code>key</code>. This just acts as an ID for the node allowing easier filtering. It has serves no other purpose.</p>"},{"location":"usage/#deep-ui-hierarchies","title":"Deep UI hierarchies","text":"<p>You can pass <code>HazeState</code> objects to composables as arguments. For example:</p> <pre><code>@Composable\nfun HazeExample(modifier: Modifier = Modifier) {\n    val hazeState = rememberHazeState()\n\n    Box(modifier = modifier) {\n        Background(\n          hazeState = hazeState,\n          modifier = Modifier.fillMaxSize()\n        )\n        Foreground(\n          hazeState = hazeState,\n          modifier = Modifier.fillMaxSize()\n        )\n    }\n}\n</code></pre> <p>You can then use the argument to configure <code>hazeSource</code> and <code>hazeEffect</code>:</p> <pre><code>@OptIn(ExperimentalHazeMaterialsApi::class)\n@Composable\nfun Foreground(\n  hazeState: HazeState,\n  modifier: Modifier = Modifier\n) {\n    Box(modifier = modifier) {\n        Text(\n            text = stringResource(R.string.haze_text),\n            modifier = modifier\n                .align(Alignment.Center)\n                .wrapContentSize()\n                .hazeEffect(\n                    state = hazeState,\n                    style = HazeMaterials.ultraThin()\n                )\n        )\n    }\n}\n</code></pre> <p>However, this can problematic in deep hierarchies when you need to pass the <code>HazeState</code> instances down through many levels. To avoid this you can use a composition local to pass the <code>HazeState</code> down to the descendants in the hierarchy:</p> <pre><code>val LocalHazeState = compositionLocalOf { HazeState() }\n\n@Composable\nfun HazeExample(modifier: Modifier = Modifier) {\n    val hazeState = rememberHazeState()\n\n    CompositionLocalProvider(LocalHazeState provides hazeState) {\n        Box(modifier = modifier) {\n            Background(modifier = Modifier.fillMaxSize())\n            Foreground(modifier = Modifier.fillMaxSize())\n        }\n    }\n}\n\n@OptIn(ExperimentalHazeMaterialsApi::class)\n@Composable\nfun Foreground(modifier: Modifier = Modifier) {\n  Box(modifier = modifier) {\n    Text(\n      text = stringResource(R.string.haze_text),\n      modifier = modifier\n        .align(Alignment.Center)\n        .wrapContentSize()\n        .hazeEffect(\n          state = LocalHazeState.current,\n          style = HazeMaterials.ultraThin()\n        )\n    )\n  }\n}\n</code></pre>"},{"location":"usage/#dialogs","title":"Dialogs","text":"<p>You can use Haze with <code>Dialog</code>s, to blur dialog backgrounds over content. We supply a HazeDialog composable to make this easy to integrate.</p> <p>A sample is available too: DialogSample.</p>"},{"location":"usage/#enabling-blur","title":"Enabling blur","text":"<p>Whether blurring is enabled or not can be controlled in two ways:</p> <ul> <li>The HazeState: <code>rememberHazeState(blurEnabled = true)</code>, </li> <li>Or on each individual <code>hazeEffect</code>:</li> </ul> <pre><code>Modifier.hazeEffect(...) {\n    blurEnabled = true\n}\n</code></pre>"},{"location":"usage/#screenshot-testing","title":"Screenshot testing","text":"<p>Haze support screenshot testing. It is itself heavily screenshot tested, using Roborazzi on both JVM Desktop and Android (Robolectric).</p> <p>When using Robolectric it is important to take note of what SDK Level you are running against. When running on Android, Haze uses the built-in RenderEffect.createBlurEffect using the CLAMP tile mode. This enables the blur effect to work correctly at the edges of the area. Support for the CLAMP tile mode was only added in Robolectric recently, and requires your tests to be running against SDK 35 (or above).</p> <p>If your tests are running against an earlier SDK Level (say 33), you may find that the edges any blurred areas look strange and incorrect. This only affects your tests though. The fix is fairly simple: update your screenshot tests to use SDK Level 35+, like so: <code>@Config(sdk = [35])</code>.</p> <p>Other host screenshot testing libraries may work, but they have not tested and I have no bandwidth to support them. YMMV.</p>"},{"location":"using-snapshot-version/","title":"Using a Snapshot Version of the Library","text":""},{"location":"using-snapshot-version/#using-a-snapshot-version-of-the-library","title":"Using a Snapshot Version of the Library","text":"<p>If you would like to depend on the cutting edge version of the library, you can use the snapshot versions that are published to Sonatype OSSRH's snapshot repository. These are updated on every commit to <code>main</code>.</p> <p>To do so:</p> <pre><code>repositories {\n    // ...\n    maven { url 'https://oss.sonatype.org/content/repositories/snapshots' }\n}\n\ndependencies {\n    // Check the latest SNAPSHOT version from the link above\n    classpath 'dev.chrisbanes.haze:haze:XXX-SNAPSHOT'\n}\n</code></pre> <p>You might see a number of different versioned snapshots. If we use an example:</p> <ul> <li><code>0.3.0-SNAPSHOT</code> is a build from the <code>main</code> branch, and depends on the latest tagged Jetpack Compose release (i.e. alpha03).</li> </ul> <p>These builds are updated regularly, but there's no guarantee that we will create one for a given snapshot number.</p> <p>Note: you might also see versions in the scheme <code>x.x.x.ui-YYYY-SNAPSHOT</code>. These are the same, just using an older suffix.</p>"}]}