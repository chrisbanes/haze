{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Haze is a library providing a 'glassmorphism' style blur for Compose.</p> <p></p> <p>Haze is built with Compose Multiplatform, meaning that it supports different platforms:</p> Platform Supported Android \u2705 Desktop (JVM) \u2705 iOS \u2705 Wasm \u2705 JS/Canvas \u2705 <p>You can also see it in action in the Tivi app:</p> <p></p>"},{"location":"#download","title":"Download","text":"<pre><code>repositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"dev.chrisbanes.haze:haze:&lt;version&gt;\")\n}\n</code></pre>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>In previous versions, the Skia-backed implementation (used on iOS and Desktop) was heavily influenced by Kirill Grouchnikov's explorations on Compose Desktop. He wrote about it in his Shader based render effects in Compose Desktop with Skia blog post.</p> <p>The Android implementation was inspired by the techniques documented by Chet Haase and Nader Jawad in the RenderNode for Bigger, Better Blurs blog post.</p> <p>Thank you all.</p>"},{"location":"#license","title":"License","text":"<pre><code>Copyright 2024 Chris Banes\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    https://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"faq/","title":"FAQs","text":""},{"location":"faq/#whats-the-difference-between-this-and-modifierblur","title":"What's the difference between this and Modifier.blur?","text":"<p>The Modifier.blur modifier and Haze may sound similar, but what they provide is different.</p> <p>Haze primarily provides background blurring, meaning that it will blur content behind, not the content itself. This is typically required to implement glass-like effects. <code>Modifier.blur</code> performs 'foreground blurring' (or content blurring) where the content in the node itself is blurred. Haze can work in this mode too, but it's not the primary goal.</p> <p>Other than that, Haze provides a whole bunch of other features which you can read about on the Usage page.</p>"},{"location":"faq/#are-the-blur-implementations-the-same-across-different-platforms","title":"Are the blur implementations the same across different platforms?","text":"<p>The short answer to this is yes. The majority of the implementation is the same across all platforms.</p> <p>The only differences are in how the blur effect is implemented, especially on Android.</p> <p>For most platforms we can use on RenderEffects to implement the blurring, but the implementations used are platform specific. All of the platforms implement them in a very similar, its just the platform classes being used which are different.</p>"},{"location":"faq/#what-versions-of-android-does-haze-work-on","title":"What versions of Android does Haze work on?","text":"<p>See the Platforms page for a detailed run down of what is supported on various platforms.</p>"},{"location":"materials/","title":"Materials","text":"<p>We provide off of the shelf implementations of HazeStyles which implement 'materials' of various styles.</p>"},{"location":"materials/#download","title":"Download","text":"<pre><code>repositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"dev.chrisbanes.haze:haze-materials:&lt;version&gt;\")\n}\n</code></pre>"},{"location":"materials/#hazematerials","title":"HazeMaterials","text":"<p>A class which contains functions to build HazeStyles which implement 'material-like' styles. It is inspired by the material APIs available in SwiftUI, but it makes no attempt to provide the exact effects provided in iOS (unlike CuperintoMaterials below).</p> <p></p> <p>Class reference: HazeMaterials.</p>"},{"location":"materials/#cupertinomaterials","title":"CupertinoMaterials","text":"<p>A class which contains functions to build HazeStyles which implement 'material' styles similar to those available on Apple platforms. The values used are taken from the iOS 18 Figma file published by Apple.</p> <p>The primary use case for using these is for when aiming for consistency with native UI (i.e. for when mixing Compose Multiplatform content alongside SwiftUI content).</p> <p></p> <p>Class reference: CupertinoMaterials.</p>"},{"location":"materials/#fluentmaterials","title":"FluentMaterials","text":"<p>These implement 'material' styles similar to those available on Windows platforms. The values used are taken from the WinUI 3 Figma file published by Microsoft.</p> <p>The primary use case for using these is for when aiming for consistency with native UI (i.e. for when mixing Compose Multiplatform content alongside WinUI content).</p> <p></p> <p>Class reference: FluentMaterials.</p>"},{"location":"materials/#usage","title":"Usage","text":"<p>All of these are provided through functions on the relevant materials class, with each function providing a different level of material.</p> <pre><code>Box {\n  // rest of sample from above\n\n  LargeTopAppBar(\n    modifier = Modifier\n      .hazeEffect(\n        ...\n        style = HazeMaterials.thin(),\n      ),\n  )\n}\n</code></pre>"},{"location":"migrating-1.0/","title":"Migrating to 1.0","text":""},{"location":"migrating-1.0/#changes","title":"Changes","text":"<p>Here's a list of known changes in v1.0.x. There may be others, so please file issues if you encounter other unexpected changes.</p>"},{"location":"migrating-1.0/#functional-changes","title":"Functional changes","text":""},{"location":"migrating-1.0/#haze-no-longer-clips-background-content","title":"Haze no longer clips background content","text":"<p>This means that blurred areas may appear less blurry at first, as you're seeing the original content behind, and then the blurred content on top. This clipping has been removed, as the clipped areas can't take part in translations, scales, etc.</p> <p>Change: Use the <code>backgroundColor</code> property on <code>HazeStyle</code> to set an appropriate opaque background color. The <code>HazeMaterial</code>s automatically use the Material3 Surface color, so you may have nothing to do here.</p>"},{"location":"migrating-1.0/#blurred-effect-may-look-different","title":"Blurred effect may look different","text":"<p>As we're now using a common implementation on all platforms, the Skia-backed platforms now have a completely different implementation. Haze has also tried to maintain consistency across the platforms, so the differences should be small. However the differences will likely trigger screenshot tests to fail.</p> <p>Change: This is working as intended for small changes, so go ahead and update your screenshot golden images. If you feel that the differences are too large, please file an issue with examples.</p>"},{"location":"migrating-1.0/#api-changes","title":"API changes","text":""},{"location":"migrating-1.0/#more-styling-parameters","title":"More styling parameters","text":"<ul> <li>What: We now have more styling parameters, including a mask <code>Brush</code>, and alpha parameter.</li> <li>Why: More is more, right?</li> </ul>"},{"location":"migrating-1.0/#hazechildscope","title":"\ud83c\udd95 HazeChildScope","text":"<ul> <li>What: We now have a parameter on <code>Modifier.hazeChild</code> which allow you to provide a lambda block for controlling all of Haze's styling parameters. It is similar to concept to <code>Modifier.graphicsLayer { ... }</code>. See here for more information.</li> <li>Why: This has been primarily added to aid animating Haze's styling parameters, in a performant way.</li> </ul>"},{"location":"migrating-1.0/#default-style-functionality-on-modifierhaze-has-been-moved","title":"Default style functionality on Modifier.haze has been moved","text":"<ul> <li>What: In previous versions, there was a <code>style</code> parameter on <code>Modifier.haze</code>, which has been moved in v1.0.</li> <li>Migration: Use the new LocalHazeStyle composition local instead.</li> <li>Why: Composition locals are used throughout styling frameworks, so this is a better API going forward.</li> </ul>"},{"location":"migrating-1.0/#hazearea-has-been-removed","title":"HazeArea has been removed","text":"<ul> <li>What: The <code>HazeArea</code> class has been removed</li> <li>Migration: None. This was mostly an internal API so if you did have a use case for this, let me know via an issue.</li> <li>Why: HazeArea instances were how we updated <code>Modifier.haze</code> instances about individual children (back-writes). With the changes listed below, drawing is now the responsibility of the children themselves, therefore there is no need to communicate this state back up.</li> </ul>"},{"location":"migrating-1.0/#why-have-these-changes-been-made","title":"Why have these changes been made?","text":"<p>Below we'll go through some of the background of the changes in v1.0. You don't need to know this stuff, but it might be interesting for some.</p>"},{"location":"migrating-1.0/#graphicslayers","title":"GraphicsLayers","text":"<p>For Haze, the most exciting APIs we now have access are the new GraphicsLayer APIs. These are very similar to RenderNodes in Android, which Haze has always used on Android. In a very short summary, GraphicsLayers give us a common API to use on all platforms.</p> <p>This has resulted in Haze now having a single implementation across all platforms now, re-using the old Android implementation. This should help minimize platform differences, and bugs.</p>"},{"location":"migrating-1.0/#new-pipeline","title":"New pipeline","text":"<p>In v0.7 and older, Haze is all 'smoke and mirrors'. It draws all of the blurred areas in the <code>haze</code> layout node. The <code>hazeChild</code> nodes just update the size, shape, etc, which the <code>haze</code> modifier reads, to know where to draw.</p> <p>With the adoption of GraphicsLayers, we now have a way to pass 'drawn' content around, meaning that we are no longer bound by the restraints of before. v1.0 contains a re-written drawing pipeline, where the blurred content is drawn by the <code>hazeChild</code>, not the parent. The parent <code>haze</code> is now only responsible for drawing the background content into a graphics layer, and putting it somewhere for the children to access.</p> <p>This fixes a number of long-known issues on Haze, where all were caused by the fact that the blurred area wasn't drawn by the child.</p>"},{"location":"performance/","title":"Performance","text":"<p>Real-time blurring is a non-trivial operation, especially for mobile devices, so developers are rightly worried about the performance impact of using something like Haze.</p> <p>Haze tries to use the most performant mechanism possible on each platform, which can basically be simplified into 2: <code>RenderEffect</code> on Android, and using Skia's <code>ImageFilter</code>s directly on iOS and Desktop.</p>"},{"location":"performance/#input-scale","title":"Input Scale","text":"<p>You can provide an input scale value which determines how much the content is scaled in both the x and y dimensions, allowing the blur effect to be potentially applied over scaled-down content (and thus less pixels), before being scaled back up and drawn at the original size. You can find more information on how to use this here.</p> <p>In terms of the performance benefit which scaling provides, it's fairly small. In our Android benchmark tests, using an <code>inputScale</code> set to <code>0.5</code> reduced the cost of Haze by 5-20%. You can read more about this below.</p> <p>Cost of Haze</p> <p>Just to call out: the percentage that I mentioned is a reduction in the cost of Haze, not the total frame duration. Haze itself introduces a cost, which you can read more about below. The reduction in total frame duration duration will be in the region of 3-5%.</p>"},{"location":"performance/#benchmarks","title":"Benchmarks","text":"<p>To quantify performance, we have a number of Macrobenchmark tests to measure Haze's effect on drawing performance on Android. We'll be using these on every major release to ensure that we do not unwittingly regress performance.</p> <p>Anyway, in the words of Jerry Maguire, \"Show Me The Money\"...</p> <p>We currently have 4 benchmark scenarios, each of them is one of the samples in the sample app, and picked to cover different things:</p> <ul> <li>Scaffold. The simple example, where the app bar and bottom navigation bar are blurred, with a scrollable list. This example uses rectangular haze areas.</li> <li>Scaffold, with progressive. Same as Scaffold, but using a progressive blur.</li> <li>Images List. Each item in the list has it's own <code>hazeSource</code> and <code>hazeEffect</code>. As each item has it's own <code>hazeSource</code>, the internal haze state does not change all that much (the list item content moves, but the <code>hazeEffect</code> doesn't in terms of local coordinates). This is more about multiple testing <code>RenderNode</code>s. This example uses rounded rectangle haze areas (i.e. we use <code>clipPath</code>).</li> <li>Credit Card. A simple example, where the user can drag the <code>hazeEffect</code>. This tests how fast Haze's internal state invalidates and propogates to the <code>RenderNode</code>s. This example uses rounded rectangle haze areas like 'Images List'.</li> </ul> <p>Test setup</p> <p>All of the tests were ran with 16 iterations on a Pixel 6, running the latest version of Android available.</p> <p>As with all benchmark tests, the results are only true for the exact things being tested. Using Haze in your own applications may result in different performance characteristics, so it is wise to write your own performance tests to validate the impact to your apps. Benchmark tests will always have variability in them too, so don't take the numbers listed below as exact values. Look at them more as a guide.</p> <p>The numbers listed below the P90 frame durations in milliseconds, which tend to be a good indicator of frames where a user interaction is happening (scrolling, etc). However, as these are the P90 values, these indicate the longest 10% frame durations, and thus are (probably) not indicitive of the performance which users see most of the time. It all depends on the distribution of the frame durations, but we're quickly getting into entry-level statistics, which is beyond what we're trying to document here.</p>"},{"location":"performance/#cost-of-haze","title":"Cost of Haze","text":"<p>We can also measure the rough cost of using Haze in the same samples. Here we've ran the same tests, with Haze being completely disabled:</p> Test 1.0.x (disabled) 1.0.x Difference Scaffold 7.5 ms 9.7 ms +29% Images List 6.6 ms 9.6 ms +45% Credit Card 6.6 ms 13.1 ms +98%"},{"location":"performance/#cost-of-features","title":"Cost of features","text":"<p>We can also measure the rough cost of using features, such as input scale, progressive and masking:</p> Test P90 frame duration (ms) Difference (in Haze cost) Scaffold 9.7 ms - Scaffold (inputScale = 0.5) 9.6 ms -5% Scaffold (masked) 9.8 ms +5% Scaffold (progressive) 9.7 ms 0% Scaffold (progressive, inputScale = 0.5) 9.4 ms -14% <p>The values are all very close, with the differences easily being within a margin of error, so don't use these differences as exact values (especially with the variability that we mentioned above). I think there's two big take aways here though:</p> <ul> <li>Masking has a negligible effect on frame durations.</li> <li>Progessive has a negligible effect on frame durations, when using using our custom blur shader (Android SDK 34+, all other platforms).</li> <li>Input Scale has a small but positive effect on frame duration.</li> </ul> <p>Full results</p> <p>For those interested, you can find the full results in this spreadsheet.</p>"},{"location":"platforms/","title":"Platforms","text":"<p>Haze works on all platforms which Compose Multiplatform supports.</p> <p>Compose Multiplatform platforms</p> <p>Please note, the list of platforms which Compose Multiplatform (CMP) supports is different to the platforms which Kotlin Multiplatform supports. Please stop raising issues about adding \"MacOS\" support; it is not supported (directly) by CMP.</p>"},{"location":"platforms/#android","title":"Android","text":""},{"location":"platforms/#android-14","title":"Android 14+","text":"<p>SDK Levels: 33+</p> <p>Haze is in its optimal environment for all use cases when running on recent versions of Android.</p>"},{"location":"platforms/#android-12-13","title":"Android 12 &amp; 13","text":"<p>SDK Levels: 31 &amp; 32</p> <p>When running on these versions of Android, Haze needs to use a few workarounds:</p>"},{"location":"platforms/#hazeprogressive","title":"HazeProgressive","text":"<p>Only linear gradient HazeProgressive effects are supported, and are implemented via a mechanism which draws the effect multiple times. This can hurt performance, so it is recommended to verify the performance of this yourself.</p> <p>You can disable this behavior by setting the preferPerformance property. When set to true, the progressive 'effect' will instead be drawn via a mask:</p> <pre><code>LargeTopAppBar(\n  // ...\n  modifier = Modifier.hazeEffect(hazeState) {\n    progressive = HazeProgressive.verticalGradient(\n      // ...\n      preferPerformance = true,\n    )\n  }\n)\n</code></pre> <p>All other progressive types will fallback to using a mask when running on Android 12 &amp; 13.</p>"},{"location":"platforms/#android-12-and-below","title":"Android 12 and below","text":"<p>When running on Android 12 and below, we can not rely on RenderNode (which GraphicsLayer use internally) re-painting when content changes. For this reason, Haze previously disabled blurring effects on Android 12 by default, as we could not guarantee that it works.</p> <p>As of Haze v1.6 and newer though, we have a mechanism allowing Haze to re-enable blurring on Android 12 by default.</p> <p>This same mechanism is required to enable blurring to work on Android 11 and below too, when enabled (more on that below).</p> Manual invalidation mechanism <p>The mechanism involves Haze manually invalidating the graphics layers manually when necessary, using 'pre draw' events. This document is not the place to go deep into 'pre draw' events, but the main point here is that Compose does not send a pre-draw event itself, so Haze needs to use the host view system's listener (via ViewTreeObserver). This means that we are not subscribing to when our particular draw nodes are about to draw, but instead we are called whenever anything is about to be drawn on screen.</p> <p>The TL;DR of this section is that the event we listen to is a lot more global than we need. Ideally we would have a way to know when the <code>hazeSource</code> node is about to be drawn (and only when the node is about to be drawn) but that functionality does not exist.</p> <p>The downside to this mechanism is that it will trigger more invalidations than what is really needed. We're effectively negating some of the granular invalidations which Compose enables through it's phasing system. It should not cause your apps any performance issues, but you can disable blurring if necessary. See docs here for more information.</p>"},{"location":"platforms/#android-11-and-below","title":"Android 11 and below","text":"<p>SDK Levels: 30 and below</p> <p>On Android 11 and below, blurring by default is disabled. When disabled, a scrim (translucent overlay) implementation is used which looks like so:</p> <p></p>"},{"location":"platforms/#renderscript-blurring","title":"RenderScript blurring","text":"<p>\ud83c\udd95 in Haze 1.6 is an implementation of blurring which uses RenderScript.</p> <p>Experimental</p> <p>Blurring on Android 11 and below is not enabled by default, and is considered experimental.</p> <p>We may enable it by default in the future, or we may just remove it all together if it is deemed too unstable. Lots of testing and feedback is required, so please raise issues if you find any problems.</p> <p>Using RenderScript does come with some drawbacks compared to RenderEffect which we use on Android 12+. The biggest is that RenderScript and your drawn content are two distinct things, which means that for Haze to blur your composable content, we need to draw it somewhere which RenderScript can read, and then also write to. This results in copying of data, which makes this blurring implementation quite slow.</p> <p>As this implementation is slow, it means that processing a frame can easily take longer than our allocated frame budget time. To combat this, Haze uses a background thread to process and blur frames, but this comes with the drawback that content updates will nearly always be a frame (or more) behind. In addition to this, Haze will only ever process one frame at a time. If a new draw is called and Haze is still processing a previous frame, Haze will simply ignore it. This is to ensure that Haze does not unintentionally create a queue of frames, and potentially overwhelm the device.</p> <p>To the user the blur effect may look 'laggy' or slow to update, especially when the background content changes a lot. This is the compromise which we have decided to make in Haze, but in my opinion it is more than good enough for the majority of use cases.</p> <p></p> <p>As mentioned above, blurring on Android 11 and below is not enabled by default. See the docs here on how to enable it.</p> <p>One final thing to note is that Haze needs to use the \"Manual invalidation mechanism\" mentioned above for this to work.</p> <p>Thanks</p> <p>Big thanks to Serhii Yaremych for his help on this, as we have managed to get an optimized 'content write' working. \ud83d\ude80</p>"},{"location":"platforms/#desktop","title":"Desktop","text":"<p>Desktop JVM is a Compose Multiplatform target which is built upon Skiko, so see the Skiko docs below.</p>"},{"location":"platforms/#ios","title":"iOS","text":"<p>iOS is a Compose Multiplatform target which is built upon Skiko, so see the Skiko docs below.</p>"},{"location":"platforms/#web","title":"Web","text":"<p>Compose for Web is based on Kotlin/Wasm, and is a Compose Multiplatform target which is built upon Skiko, so see the Skiko docs below.</p>"},{"location":"platforms/#skiko","title":"Skiko","text":"<p>Most of the Compose Multiplatform targets are built on top of Skiko, which is a bundled version of the Skia Graphics Library with Kotlin bindings.</p> <p>As Skiko bundles Skia into the app binaries, this means that the host platform we're running on is not particularly important to Haze. All of that is hopefully handled by the platform integration layers in CMP, Skiko and Skia.</p> <p>The most important thing when running on these platforms is the library versions we're built against. Haze is always built, tested and released against the latest stable version of Compose Multiplatform.</p> <p>Other than that, running on a Skiko-backed platform means that Haze is running in its optimal environment.</p>"},{"location":"platforms/#using-pre-release-versions-of-compose-multiplatform","title":"Using pre-release versions of Compose Multiplatform","text":"<p>We do occasionally verify against pre-release versions of CMP, but it's not something we guarantee. If you want to use a pre-release version of Compose Multiplatform, then please test it thoroughly.</p>"},{"location":"recipes/","title":"Recipes","text":""},{"location":"recipes/#scaffold","title":"Scaffold","text":"<p>Blurring the content behind app bars is a common use case, so how can we use Haze with <code>Scaffold</code>? It's pretty much the same as above:</p> <p>Multiple hazeEffects</p> <p>Note: We are using multiple <code>hazeEffect</code>s in this example. You can actually use an abitrary number of <code>hazeEffect</code>s.</p> <pre><code>val hazeState = rememberHazeState()\n\nScaffold(\n  topBar = {\n    TopAppBar(\n      // Need to make app bar transparent to see the content behind\n      colors = TopAppBarDefaults.largeTopAppBarColors(Color.Transparent),\n      modifier = Modifier\n        .hazeEffect(state = hazeState)\n        .fillMaxWidth(),\n    ) {\n      /* todo */\n    }\n  },\n  bottomBar = {\n    NavigationBar(\n      containerColor = Color.Transparent,\n      modifier = Modifier\n        .hazeEffect(state = hazeState)\n        .fillMaxWidth(),\n    ) {\n      /* todo */\n    }\n  },\n) {\n  LazyVerticalGrid(\n    modifier = Modifier\n      .hazeSource(\n        state = hazeState,\n        style = HazeDefaults.style(backgroundColor = MaterialTheme.colorScheme.surface),\n      ),\n  ) {\n    // todo\n  }\n}\n</code></pre>"},{"location":"recipes/#sticky-headers","title":"Sticky Headers","text":"<p>The <code>stickyHeader</code> functionality on <code>LazyColumn</code> and friends is very useful, but unfortunately the limitations of Haze means that blurring the list contents for the header background is tricky.</p> <p>Since we can not use <code>Modifier.hazeSource</code> on the <code>LazyColumn</code> and <code>Modifier.hazeEffect</code> on items, as we would get into recursive drawing, we need to get a bit more creative.</p> <p>Since we can have multiple nodes using <code>Modifier.hazeSource</code>, we can use the modifier on all non-header items, and then use <code>hazeEffect</code> as normal on the <code>stickyHeader</code>:</p> <pre><code>val hazeState = rememberHazeState()\n\nLazyColumn(...) {\n  stickyHeader {\n    Header(\n      modifier = Modifier\n        .hazeEffect(state = hazeState),\n    )\n  }\n\n  items(list) { item -&gt;\n    Foo(\n      modifier = Modifier\n        .hazeSource(hazeState),\n    )\n  }\n}\n</code></pre> <p>A more complete example can be found here: ListWithStickyHeaders.</p> <p></p>"},{"location":"usage/","title":"Usage","text":"<p>Haze works has two modes: 'background blurring', and 'foreground blurring', and the way you use them is extremely similar. Most of this page will assume that you wish to use 'background blurring', as it's the most common, but there is a section at the bottom of this page to outline how to perform 'foreground blurring'.</p> <p>Haze is implemented through two Compose Modifiers: Modifier.hazeSource and Modifier.hazeEffect.</p> <p>The most basic usage would be something like:</p> <pre><code>val hazeState = rememberHazeState()\n\nBox {\n  LazyColumn(\n    modifier = Modifier\n      .fillMaxSize()\n      // Pass it the HazeState we stored above\n      .hazeSource(state = hazeState)\n  ) {\n    // todo\n  }\n\n  LargeTopAppBar(\n    // Need to make app bar transparent to see the content behind\n    colors = TopAppBarDefaults.largeTopAppBarColors(Color.Transparent),\n    modifier = Modifier\n      // We use hazeEffect on anything where we want the background\n      // blurred.\n      .hazeEffect(state = hazeState, style = HazeMaterials.ultraThin())\n      .fillMaxWidth(),\n  )\n}\n</code></pre> <p>You will notice that were using a style created by <code>HazeMaterials.ultraThin()</code>. The HazeMaterials are sets of prebuilt styles that are available as an add-on library.</p> <p>If you do not provide an explicit style, the default values will provide basic blurring, but no tinting. It's recommended to use one of the materials linked above, or a custom style which meets your requirements.</p>"},{"location":"usage/#styling","title":"Styling","text":"<p>Haze has support for customizing the resulting effect, which is performed via the HazeStyle class, or the lambda block provided to <code>hazeEffect</code>.</p> <p>Styles can be provided in a number of different ways:</p> <ul> <li>LocalHazeStyle composition local.</li> <li>The style parameter on Modifier.hazeEffect.</li> <li>By setting the relevant property in the optional HazeEffectScope lambda <code>block</code>, passed into Modifier.hazeEffect.</li> </ul>"},{"location":"usage/#hazeeffectscope","title":"HazeEffectScope","text":"<p>We now have a parameter on <code>Modifier.hazeEffect</code> which allow you to provide a lambda block, for controlling all of Haze's styling parameters. It is similar to concept to <code>Modifier.graphicsLayer { ... }</code>.</p> <p>It's useful for when you need to update styling parameters, using values derived from other state. Here's an example which fades the effect as the user scrolls:</p> <pre><code>FooAppBar(\n  ...\n  modifier = Modifier\n    .hazeEffect(state = hazeState) {\n      alpha = if (listState.firstVisibleItemIndex == 0) {\n        listState.layoutInfo.visibleItemsInfo.first().let {\n          (it.offset / it.size.height.toFloat()).absoluteValue\n        }\n      } else {\n        alpha = 1f\n      }\n    },\n)\n</code></pre>"},{"location":"usage/#styling-resolution","title":"Styling resolution","text":"<p>As we a few different ways to set styling properties, it's important to know how the final values are resolved.</p> <p>Each styling property (such as <code>blurRadius</code>) is resolved seperately, and the order of precedence for each property is as follows, in order:</p> <ul> <li>Value set in HazeEffectScope, if specified.</li> <li>Value set in style provided to hazeEffect (or HazeEffectScope.style), if specified.</li> <li>Value set in the LocalHazeStyle composition local.</li> </ul>"},{"location":"usage/#styling-properties","title":"Styling properties","text":""},{"location":"usage/#blur-radius","title":"Blur Radius","text":"<p>The blur radius controls how strong the blur effect is. This defaults to <code>20.dp</code> but can be customized as needed. Larger values might be needed to keep foreground control (such as text) legible and accessible.</p>"},{"location":"usage/#tint","title":"Tint","text":"<p>A tint effect is applied, primarily to maintain contrast and legibility. By default we use the provided background color at 70% opacity. You may wish to use a different color or opacity. You provide multiple tints, which will be applied in sequence.</p>"},{"location":"usage/#noise","title":"Noise","text":"<p>Some visual noise is applied, to provide some tactility. This is completely optional, and defaults to a value of <code>0.15f</code> (15% strength). You can disable this by providing <code>0f</code>.</p>"},{"location":"usage/#progressive-aka-gradient-blurs","title":"Progressive (aka gradient) blurs","text":"<p>Progressive blurs allow you to provide a visual effect where the blur radius is varied over a dimension. You may have seen this effect used on iOS.</p> <p></p> <p>Progressive blurs can be enabled by setting the <code>progressive</code> property on HazeEffectScope. The API is very similar to the Brush gradient APIs, so it should feel familiar.</p> <pre><code>LargeTopAppBar(\n  // ...\n  modifier = Modifier.hazeEffect(hazeState) {\n    progressive = HazeProgressive.verticalGradient(startIntensity = 1f, endIntensity = 0f)\n  }\n)\n</code></pre> <p>There are a number of different types of progressive effect supported in Haze:</p>"},{"location":"usage/#linear-gradient","title":"Linear Gradient","text":"<p>Class documentation: HazeProgressive.LinearGradient</p> <p>Linear gradients, usually vertical or horizontal, but you can set any angle.</p> <p>There are a few builder functions on <code>HazeProgressive</code>, enabling common use cases: verticalGradient and horizontalGradient.</p> <pre><code>LargeTopAppBar(\n  // ...\n  modifier = Modifier.hazeEffect(hazeState) {\n    progressive = HazeProgressive.verticalGradient(startIntensity = 1f, endIntensity = 0f)\n  }\n)\n</code></pre>"},{"location":"usage/#radial-gradient","title":"Radial Gradient","text":"<p>Class documentation: HazeProgressive.RadialGradient</p> <p>A radial gradient, with a defined center and radius.</p> <pre><code>LargeTopAppBar(\n  // ...\n  modifier = Modifier.hazeEffect(hazeState) {\n    progressive = HazeProgressive.RadialGradient()\n  }\n)\n</code></pre>"},{"location":"usage/#custom-brush","title":"Custom Brush","text":"<p>Class documentation: HazeProgressive.Brush</p> <p>A custom progressive effect, using a given Brush as the alpha mask for the entire effect.</p> <p>Commonly this will be used to create along with a custom Shader, so we have a builder function to make this easier: forShader</p> <pre><code>LargeTopAppBar(\n  // ...\n  modifier = Modifier.hazeEffect(hazeState) {\n    progressive = HazeProgressive.forShader { size -&gt;\n      // TODO: return platform-specific Shader using the given size\n    }\n  }\n)\n</code></pre> <p>The Shader class is not commonized in Compose Multiplatform (it's an alias to the platform specific class), therefore you will likely need to use <code>expect</code> and <code>actual</code> functions to build the relevant shader.</p> <p>Performance of Progressive</p> <p>Please be aware that using progressive blurring does come with a performance cost. Please see the Performance page for up-to-date benchmarks.</p> <p>As a quick summary: on Android SDK 33+ and other platforms, the cost is about 25% more than non-progressive. On Android SDK 32 it is about 2x. If performance is critical, you may wish to look at the masking functionality below.</p>"},{"location":"usage/#masking","title":"Masking","text":"<p>You can provide any Brush, which will be used as a mask when the final effect is drawn.</p> <pre><code>LargeTopAppBar(\n  // ...\n  modifier = Modifier.hazeEffect(hazeState) {\n    mask = Brush.verticalGradient(...)\n  }\n)\n</code></pre> <p>Mask vs Progressive</p> <p>When you provide a gradient brush as a mask, the effect is visually similar to a gradient blur. The difference is that the effect is faded through opacity only, and may not feel as refined. However, it is much faster than progressive blurring, having a negligible cost.</p>"},{"location":"usage/#input-scale","title":"Input Scale","text":"<p>You can provide an input scale value which determines how much the content is scaled in both the x and y dimensions, allowing the blur effect to be potentially applied over scaled-down content (and thus less pixels), before being scaled back up and drawn at the original size.</p> <p></p> <pre><code>LargeTopAppBar(\n  // ...\n  modifier = Modifier.hazeEffect(hazeState) {\n    inputScale = HazeInputScale.Auto\n  }\n)\n</code></pre> <p>HazeInputScale has a number of different options:</p> <ul> <li><code>HazeInputScale.None</code>: Turns off input scaling (default)</li> <li><code>HazeInputScale.Auto</code>: Turns on input scaling, with automatic values derived underneath.</li> <li><code>HazeInputScale.Fixed(...)</code>: Turns on input scaling, using the value you pass in.</li> </ul> <p>When using a <code>Fixed</code> value, less than 1.0 may improve performance, at the sacrifice of quality and crispness. As always, run your own benchmarks as to whether this compromise is worth it.</p> <p>If you're looking for a good value to experiment with, <code>0.66</code> results in a reduction in total resolution of ~55%, while being visually imperceptible to most people (probably).</p> <p>The minimum value I would realistically use is somewhere in the region of <code>0.33</code>, which results in the total pixel count of only 11% of the original content. This is likely to be visually different to no scaling, but depending on the styling parameters, it will be visually pleasing to the user.</p>"},{"location":"usage/#overlapping-blurred-layouts","title":"Overlapping blurred layouts","text":"<p>A layout node can use both a <code>Modifier.hazeEffect</code>, drawing a blurred effect from other areas, and use <code>Modifier.hazeSource</code> to draw itself for other <code>hazeEffect</code> users.</p> <p>This nested functionality sounds complicated, but in reality it enables a simple use case: overlapping blurred layout nodes.</p> <p></p> <p>This code to implement this is like below. You can see that the <code>CreditCard()</code> nodes use both the <code>hazeSource</code> and <code>hazeEffect</code> modifiers. Pay attention to the modifier order here.</p> <pre><code>Box {\n  val hazeState = rememberHazeState()\n\n  Background(\n    modifier = Modifier\n      .hazeSource(hazeState, zIndex = 0f)\n  )\n\n  // Rear card\n  CreditCard(\n    modifier = Modifier\n      .hazeSource(hazeState, zIndex = 1f)\n      .hazeEffect(hazeState)\n  )\n\n  // Middle card\n  CreditCard(\n    modifier = Modifier\n      .hazeSource(hazeState, zIndex = 2f)\n      .hazeEffect(hazeState),\n  )\n\n  // Front card\n  CreditCard(\n    modifier = Modifier\n      .hazeSource(hazeState, zIndex = 3f)\n      .hazeEffect(hazeState)\n  )\n}\n</code></pre> <p>You will notice that there's something different here, the <code>zIndex</code> parameter.</p> <p>For this to work you need to pass in the <code>zIndex</code> parameter of the node. It doesn't matter if you use <code>Modifier.zIndex</code>, or the implicit ordering from the layout, you need to explicitly pass in a valid <code>zIndex</code> value.</p>"},{"location":"usage/#zindex","title":"zIndex","text":"<p>Internally, the zIndex value is how Haze knows which layers to draw in which nodes. By default, <code>hazeEffect</code> will draw all layers with a <code>zIndex</code> less than the value of the sibling <code>Modifier.hazeSource</code>. So in the example above, the middle card (<code>zIndex</code> of 2) will draw the rear card (<code>zIndex</code> of 1) and background (<code>zIndex</code> of 0).</p> <p>This default behavior is usually the correct behavior for all use cases, but you can modify this behavior via the <code>canDrawArea</code> parameter, which acts as a filter when set:</p> <pre><code>CreditCard(\n  modifier = Modifier\n    .hazeSource(hazeState, zIndex = 2f, key = \"foo\")\n    .hazeEffect(hazeState) {\n      canDrawArea = { area -&gt;\n        // return true to draw\n        area.key != \"foo\"\n      }\n    },\n)\n</code></pre> <p>You'll notice that we're using another parameter here, <code>key</code>. This just acts as an ID for the node allowing easier filtering. It has serves no other purpose.</p>"},{"location":"usage/#deep-ui-hierarchies","title":"Deep UI hierarchies","text":"<p>You can pass <code>HazeState</code> objects to composables as arguments. For example:</p> <pre><code>@Composable\nfun HazeExample(modifier: Modifier = Modifier) {\n    val hazeState = rememberHazeState()\n\n    Box(modifier = modifier) {\n        Background(\n          hazeState = hazeState,\n          modifier = Modifier.fillMaxSize()\n        )\n        Foreground(\n          hazeState = hazeState,\n          modifier = Modifier.fillMaxSize()\n        )\n    }\n}\n</code></pre> <p>You can then use the argument to configure <code>hazeSource</code> and <code>hazeEffect</code>:</p> <pre><code>@OptIn(ExperimentalHazeMaterialsApi::class)\n@Composable\nfun Foreground(\n  hazeState: HazeState,\n  modifier: Modifier = Modifier\n) {\n    Box(modifier = modifier) {\n        Text(\n            text = stringResource(R.string.haze_text),\n            modifier = modifier\n                .align(Alignment.Center)\n                .wrapContentSize()\n                .hazeEffect(\n                    state = hazeState,\n                    style = HazeMaterials.ultraThin()\n                )\n        )\n    }\n}\n</code></pre> <p>However, this can problematic in deep hierarchies when you need to pass the <code>HazeState</code> instances down through many levels. To avoid this you can use a composition local to pass the <code>HazeState</code> down to the descendants in the hierarchy:</p> <pre><code>val LocalHazeState = compositionLocalOf { HazeState() }\n\n@Composable\nfun HazeExample(modifier: Modifier = Modifier) {\n    val hazeState = rememberHazeState()\n\n    CompositionLocalProvider(LocalHazeState provides hazeState) {\n        Box(modifier = modifier) {\n            Background(modifier = Modifier.fillMaxSize())\n            Foreground(modifier = Modifier.fillMaxSize())\n        }\n    }\n}\n\n@OptIn(ExperimentalHazeMaterialsApi::class)\n@Composable\nfun Foreground(modifier: Modifier = Modifier) {\n  Box(modifier = modifier) {\n    Text(\n      text = stringResource(R.string.haze_text),\n      modifier = modifier\n        .align(Alignment.Center)\n        .wrapContentSize()\n        .hazeEffect(\n          state = LocalHazeState.current,\n          style = HazeMaterials.ultraThin()\n        )\n    )\n  }\n}\n</code></pre>"},{"location":"usage/#dialogs","title":"Dialogs","text":"<p>You can use Haze with <code>Dialog</code>s, to blur dialog backgrounds over content. A sample is available: DialogSample.</p>"},{"location":"usage/#enabling-blur","title":"Enabling blur","text":"<p>Whether blurring is enabled or not can be controlled in two ways:</p> <ul> <li>The HazeState: <code>rememberHazeState(blurEnabled = true)</code>. This affects all modifiers attached to it.</li> <li>On each individual <code>hazeEffect</code> like so:</li> </ul> <pre><code>Modifier.hazeEffect(...) {\n    blurEnabled = true\n}\n</code></pre>"},{"location":"usage/#foreground-blurring","title":"Foreground blurring","text":"<p>As mentioned above, Haze also supports foreground blurring, where the content on the layout itself will be blurred by Haze and then drawn. You might be wondering why this is at the bottom of this page? Well nearly everything listed above is also applicable for 'foreground blurring'.</p> <p>The only difference with foreground blurring is that you do not need to use a <code>HazeState</code> or <code>Modifier.hazeSource</code>, you only need a <code>Modifier.hazeEffect</code>.</p> <p>To perform foreground blurring on a layout, you can do the following:</p> <pre><code>@Composable\nfun HazeExample(modifier: Modifier = Modifier) {\n  Box(modifier = modifier) {\n    Foreground(\n      modifier = Modifier\n        // Note that we do NOT pass in a HazeState\n        .hazeEffect {\n          // Use all of the same features as above\n          tints = // ...\n          progressive = // ...\n        }\n        .fillMaxSize()\n    )\n  }\n}\n</code></pre>"},{"location":"usage/#screenshot-testing","title":"Screenshot testing","text":"<p>Haze support screenshot testing. It is itself heavily screenshot tested, using Roborazzi on both JVM Desktop and Android (Robolectric).</p> <p>When using Robolectric it is important to take note of what SDK Level you are running against. When running on Android, Haze uses the built-in RenderEffect.createBlurEffect using the CLAMP tile mode. This enables the blur effect to work correctly at the edges of the area. Support for the CLAMP tile mode was only added in Robolectric recently, and requires your tests to be running against SDK 35 (or above).</p> <p>If your tests are running against an earlier SDK Level (say 33), you may find that the edges any blurred areas look strange and incorrect. This only affects your tests though. The fix is fairly simple: update your screenshot tests to use SDK Level 35+, like so: <code>@Config(sdk = [35])</code>.</p> <p>Other host screenshot testing libraries may work, but they have not tested and I have no bandwidth to support them. YMMV.</p>"},{"location":"using-snapshot-version/","title":"Using a Snapshot Version of the Library","text":""},{"location":"using-snapshot-version/#using-a-snapshot-version-of-the-library","title":"Using a Snapshot Version of the Library","text":"<p>If you would like to depend on the cutting edge version of the library, you can use the snapshot versions that are published to Sonatype Central Repository's snapshot repository. These are updated on every commit to <code>main</code>.</p> <p>To do so:</p> <pre><code>repositories {\n    // ...\n    maven(\"https://central.sonatype.com/repository/maven-snapshots\")\n}\n\ndependencies {\n    // Check the latest SNAPSHOT version from the link above\n    implementation(\"dev.chrisbanes.haze:haze:XXX-SNAPSHOT\")\n}\n</code></pre>"}]}